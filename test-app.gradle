import org.gradle.initialization.DefaultSettings

import java.nio.file.Paths

def generatedFileName = "TestAppPackageList.java"
def generatedFilePackage = "com.facebook.react"
def generatedFileContentsTemplate = """
package $generatedFilePackage;

import com.facebook.react.ReactPackage;
import java.util.Arrays;
import java.util.ArrayList;

{{ packageImports }}

public class TestAppPackageList { 
  public ArrayList<ReactPackage> getPackages() {
    return new ArrayList<>(Arrays.<ReactPackage>asList(
      {{ packageClassInstances }}
    ));
  }
}
"""

class TestAppPlugin implements Plugin<PluginAware> {
    private String generatedFileName;
    private String generatedFilePackage;
    private String generatedFileContentsTemplate;
    
    private String packageName;
    private ArrayList<HashMap<String, String>> packages = new ArrayList<>();
    
    TestAppPlugin(
        String generatedFileName, 
        String generatedFilePackage, 
        String generatedFileContentsTemplate
    ) {
        this.generatedFileName = generatedFileName;
        this.generatedFilePackage = generatedFilePackage;
        this.generatedFileContentsTemplate = generatedFileContentsTemplate;
    }

    @Override
    void apply(PluginAware target) {
        if (target instanceof Settings) {
            applyToSettings((Settings) target)
        } else if (target instanceof Project) {
            applyToProject((Project) target)
        }
    }

    /**
    * Finds the path of the installed npm package with the given name using Node's
    * module resolution algorithm, which searches "node_modules" directories up to
    * the file system root. This handles various cases, including:
    *
    *   - Working in the open-source RN repo:
    *       Gradle: /path/to/react-native/ReactAndroid
    *       Node module: /path/to/react-native/node_modules/[package]
    *
    *   - Installing RN as a dependency of an app and searching for hoisted
    *     dependencies:
    *       Gradle: /path/to/app/node_modules/react-native/ReactAndroid
    *       Node module: /path/to/app/node_modules/[package]
    *
    *   - Working in a larger repo (e.g., Facebook) that contains RN:
    *       Gradle: /path/to/repo/path/to/react-native/ReactAndroid
    *       Node module: /path/to/repo/node_modules/[package]
    *
    * The search begins at the given base directory (a File object). The returned
    * path is a string.
    */
    static def findNodeModulePath(baseDir, packageName) {
        def basePath = baseDir.toPath().normalize()

        // Node's module resolution algorithm searches up to the root directory,
        // after which the base path will be null
        while (basePath) {
            def candidatePath = Paths.get(basePath.toString(), "node_modules", packageName)
            if (candidatePath.toFile().exists()) {
                return candidatePath.toString()
            }
            basePath = basePath.getParent()
        }

        return null
    }

    private static void applyToSettings(Settings settings) {
        def projectDir = findNodeModulePath(
            settings.rootDir, "react-native-test-app");

        settings.include(":app")
        settings.project(":app")
                .projectDir = new File("${projectDir}/android/app")
    }

    private void applyToProject(Project project) {
        def appProject = project.project(":app")

        // TODO: support configurations other than implementation
        def appDependencies = appProject.getConfigurations()
                .getByName("implementation")
                .getDependencies()

        def dependency = appProject.getDependencies()
                .create(project)

        appDependencies.add(dependency)        

        packageName = getPackageName(project)
        packages = getPackages(project)
    }

    private String getPackageName(Project project) {
        def projectDir = project.projectDir.absolutePath
        
        def files = new FileNameFinder()
            .getFileNames(projectDir, "**/AndroidManifest.xml", 
                "node_modules/** **/build/** **/debug/** Examples/** examples/**")
        def manifestFile = files.first()
        def manifest = (new XmlParser()).parse(manifestFile)        

        return manifest.attribute("package")
    }

    private ArrayList<HashMap<String, String>> getPackages(Project project) {
        def projectDir = project.projectDir.absolutePath

        def javaFiles = new FileNameFinder()
            .getFileNames(projectDir, "**/*.java")
        def kotlinFiles = new FileNameFinder()
            .getFileNames(projectDir, "**/*.kt")
        
        def sourceFiles = new ArrayList<>()
        sourceFiles.addAll(kotlinFiles)
        sourceFiles.addAll(javaFiles)

        def pattern = ~/class\s+(\w+[^(\s]*)[\s\w():]*(\s+implements\s+|:)[\s\w():,]*[^{]*ReactPackage/       
        
        ArrayList<HashMap<String, String>> packages = new ArrayList<>(); 

        sourceFiles.forEach { path -> 
            def matcher = pattern.matcher(new File(path).text)
            if (matcher.find()) {
                def packageClassName = matcher.group(1);                
                def packageImportPath = "import ${packageName}.${packageClassName};"              
                def packageInstance = "new ${packageClassName}()"

                HashMap config = new HashMap<String, String>()
                config.put("packageInstance", packageInstance)  
                config.put("packageImportPath", packageImportPath)

                packages.add(config);
            }        
        }

        return packages
    }

    /**
    * Code-gen a java file with all the detected ReactNativePackage instances automatically added
    *
    * @param outputDir    
    */
    void generatePackagesFile(File outputDir) {
        String packageImports = ""
        String packageClassInstances = ""

        if (packages.size() > 0) {
            packageImports = "import ${packageName}.BuildConfig;\nimport ${packageName}.R;\n\n"
            packageImports = packageImports + packages.collect { "${it.packageImportPath}" }.join('\n')
            packageClassInstances = packages.collect { it.packageInstance }.join(",\n      ")
        }

        String generatedFileContents = generatedFileContentsTemplate
            .replace("{{ packageImports }}", packageImports)
            .replace("{{ packageClassInstances }}", packageClassInstances)

        outputDir.mkdirs()
        final FileTreeBuilder treeBuilder = new FileTreeBuilder(outputDir)
        treeBuilder.file(generatedFileName).newWriter().withWriter { w ->
            w << generatedFileContents
        }
    }
}

def plugin = new TestAppPlugin(
    generatedFileName, 
    generatedFilePackage, 
    generatedFileContentsTemplate
)

ext.applyTestAppSettings = { DefaultSettings defaultSettings -> 
    plugin.apply(defaultSettings) 
}

// TODO: make codegen smarter to merge PackageList and TestAppPackageList files
ext.applyTestAppModule = { Project project -> 
    plugin.apply(project)     

    def generatedSrcDir = new File(buildDir, "generated/rncli/src/main/java")
    def generatedCodeDir = new File(generatedSrcDir, generatedFilePackage.replace('.', '/'))

    task generateTestAppPackageList {
        doLast {            
            plugin.generatePackagesFile(generatedCodeDir)
        }
    }

    preBuild.dependsOn generateTestAppPackageList

    android {
        sourceSets {
            main {
                java {
                    srcDirs += generatedSrcDir
                }
            }
        }
    }
}
